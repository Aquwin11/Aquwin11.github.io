<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Portfolio Projects</title>

            <link rel="stylesheet" href="detail-style.css">
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
  </head>
  <body>
    <nav class="navbar">
        <a href="index.html" class="navbar-brand">Aquwin Thomas Panjikaran</a>
        <ul class="navbar-nav">
            <li class="nav-item"><a href="index.html#about">About</a></li>
            <li class="nav-item"><a href="index.html#Timeline">Resume</a></li>
            <li class="nav-item"><a href="index.html#projects">Projects</a></li>
            <li class="nav-item"><a href="index.html#contact-me">Contact</a></li>
        </ul>
        <button class="navbar-toggler">
            <span class="toggler-icon">☰</span>
        </button>
    </nav>
    <div id="project-detail-container">
        <!-- Project details will be loaded here -->
    </div>
    
	<script src="script.js"></script>
    <script>
const projects = {
    project1: {
        title: "FOUR PEBBLES",
        img: "Images/ic_newicon_foreground.png",
        tech: ["Kotlin", "Android Studio"],
        content: [
            {
                type: "link",
                value: "bi-github",
                url: "https://github.com/Aquwin11/FivePebelles",
                linkType: "icon" // Could be "text","icon" or "image" with appropriate handling
            },
            {
                type: "text",
                value: "This game was developed as part of my computer games course for Mobile Application module."
            },
            {
                type: "heading",
                value: "Design & Features"
            },
            {
                type: "text",
                value: "The game is played on a 6X6 board where the player's objective is to make a sequence of four characters of X or O horizontally, vertically, and diagonally. The major change comes in the switch button where the player swaps their symbols with their opponent which can change the flow of the game entirely. On swapping the player lose their current move and their opponent gets to play again."
            },
            /*{
                type: "image",
                value: "Images/MergedImages.png",
                alt: "Computer  Screenshot",
                orientation: "portrait" // New attribute for orientation
            },*/
            {
                type: "collapsible",
                value: "Screens",
                content: [
                    { type: "text", value: "The app has six screens that it transitions between. The settings screen gives the user control over their volume and also changes their username. The single player screen provides the player to play between two options.One the player can play against another player on the same device in the co-op mode and another where the player can play against a bot. In the Multiplayer screen, the two buttons are present create, and join were planned to open a dialog box where the player can enter the code to either create or join an existing room. The Rules section displays the rules and tips and tricks to help win the game. The gameplay screen is similar throughout the different modes." },
                    { type: "image", value: "Images/MergedImages.jpg", alt: "Example" },
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Gameplay Implementation"
            },
            {
                type: "text",
                value: "In the single-player gameplay activity of our app, we accommodate both Player VS Player and Player VS Bot modes on the same screen, with minor adjustments between the two for a tailored gaming experience. This functionality is achieved through the use of intents. Based on the game mode selected by the user in the single-player menu screen, an intent directs the user to the appropriate gameplay activity setup. The gameplay mechanics include a dynamic player array list to which the value of a clicked box is added whenever a player makes a move. This approach allows for an efficient tracking of players' positions and actions on the board. Furthermore, a switch button feature is incorporated, enabling players to swap their array lists with each other at the click of a button."
            },
            {
                type: "collapsible",
                value: "Bot",
                content: [
                    { type: "text", value: "The bot in the game operates through a decision tree, employing a sequential decision-making process to determine its actions. Initially, it checks for a possible winning move and executes it if available. If a winning move isn't viable and the opponent is positioned to win on their next turn, the bot evaluates the number of potential winning moves for the opponent. If the opponent has more than one winning move available, indicating that a simple block won't suffice, the bot opts to swap symbols with the opponent to disrupt their strategy. However, if the opponent's win can be prevented with a single block, the bot proceeds to block the opponent's winning move. Following this, the bot assesses the board for any strategic advantages, such as taking a central position or setting up a sequence that could lead to a future win. In the absence of strategic moves, it defaults to making a random move to maintain gameplay dynamics. This logical, hierarchical approach ensures the bot is not only reactive but also proactively seeks to optimize its chances of winning, balancing both offensive and defensive strategies within the game's context." },
                    { type: "gif", value: "Images/Emulator-FivePebells2024-02-0822-38-31-ezgif.com-optimize.gif", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Multiplayer"
            },
            {
                type: "text",
                value: "In the multiplayer activity of the game, the process begins when a user inputs a game code into the designated text field. Upon pressing the create button, the system first verifies whether a game room with the specified code already exists. If there is no existing room, it proceeds to create a new game room. Conversely, when a user opts to join an existing game by clicking the join button, the system checks the validity of the provided code against the game rooms registered in Firebase's real-time database. If the code corresponds to an existing room, the player is seamlessly added to that room. This entire multiplayer setup, including the creation and joining of game rooms, is meticulously managed through Firebase’s Realtime Database, offering a robust and efficient way to handle game state and player interactions in real time. The visual and interactive elements of the multiplayer gameplay activity are designed to be familiar, mirroring the single-player experience for consistency. Every action a player takes, such as clicking a box, triggers an update in the Realtime Database, which is immediately reflected on all participants' devices, ensuring that each player's moves are synchronized across the game."
            },
            {
                type: "collapsible",
                value: "CODE SNIPPET",
                content: [
                    { type: "image", value: "Images/four_database.png", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Video"
            },
            {
            type: "youtube",
            value: "PoyXHQvtQa4?si=y9vwxscPy2Q3wGR0" // Replace "VideoID" with the actual ID of the YouTube video
            },

            /*{
                
                type: "gif",
                value: "Images/dayNightGIF.gif",
                alt: "Animation Highlighting Challenges",
                orientation: "landscape"
                orientation: "landscape"
            },*/
            {
                type: "text",
                value: "The game's download link is below."
            },
            {
                type: "link",
                value: "Download",
                url: "https://aquwin11.itch.io/four-pebbels/",
                linkType: "text" // Could be "text","icon" or "image" with appropriate handling
            }
        ]
    },
    project2: {
        title: "Leggy’s Logic",
        img: "Images/Leggy.png",
        tech: ["JAVA", "JBox2D"],
        content: [
            // Example of a heading
            {
                type: "link",
                value: "bi-github",
                url: "https://github.com/Aquwin11/PhysicsFinalAs",
                linkType: "icon" // Could be "text","icon" or "image" with appropriate handling
            },
            {
                type: "text",
                value: "This game was developed as part of my computer games course for physics-based games module."
            },
            {
                type: "heading",
                value: "Introduction"
            },
            {
                type: "text",
                value: "Leggy's Logic is a puzzle platformer game that has been developed using JBox2D, which is a 2D physics engine. The game features a spider character named Leggy, and her movements are based on physics, providing a realistic experience for the player. One of the main features of the game is the character's automatic foot placement based on the terrain geometry, which enhances the player's experience of traversing through the game world. The other feature of the game is Leggy's ability to jump, shoot webs, and grapple. In this report, we will delve into the development process of these features."
            },
            {
                type: "heading",
                value: "Player Movement"
            },
            {
                type: "text",
                value: "The movement of the character is achieved by applying force to its main body. In a 'for' loop, the positions of the spider's legs are iterated to calculate the distance between the main body and each leg using the distance formula. If the calculated distance is greater than the maximum distance or less than the minimum distance, and if the leg is on the ground, then the leg moves towards the new leg position with the given speed. If the calculated distance is within the maximum and minimum distance limits or if the leg is not on the ground, the leg remains stationary by setting its linear velocity to zero. The new leg position objects are attached to the main body of the spider using a distance joint."
            },
            {
                type: "collapsible",
                value: "CODE SNIPPET",
                content: [
                    { type: "text", value: "Code for Spider’s Leg Movement." },
                    { type: "image", value: "Images/spiderLegCode.png", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Grapple & Shooting"
            },
            {
                type: "text",
                value: "The Grapple mechanic is activated when the player presses the E key near a grapple point and the conditions for grappling are fulfilled. This action triggers a sound and sets up a distance joint between the spider and the grapple point, visually represented by a line akin to a string, signifying the connection. This mechanic allows players to swing and maneuver in the environment, adding a dynamic element to navigation. Shooting is another core mechanic, where aiming is controlled by the right mouse button and firing by the left. The game calculates the trajectory and velocity of projectiles based on the coordinates of the target and the spider, creating a new projectile instance each time the player shoots."
            },
            {
                type: "heading",
                value: "Joints"
            },
            {
                type: "text",
                value: "Joints in physics are the means of connecting two or more rigid bodies in a way that enables them to move together in a specific manner. As previously mentioned, we utilized a distance joint to simulate a grappling hook and even for the spider's new leg position. In the game, joints were also implemented by combining a distance joint and a revolute joint, both anchored around the main body. This combination forces the legs to push the body upward, visually representing that the legs are holding the main body up. The entire spider body was created using revolute joints to inverse kinematics. For some objects that don’t need any kind of rotation, wield joint was used."
            },
            {
                type: "image",
                value: "Images/spideDebug.png",
                alt: "Computer  Screenshot",
                orientation: "landscape" // New attribute for orientation
            },
            {
                type: "heading",
                value: "Collision Detection"
            },
            {
                type: "text",
                value: "In the game, collision filtering was utilized to determine which objects can collide with one another, making the objects more dynamic. The same class was used to create different objects with unique functionality. Contact collision occurs when two bodies come into contact with each other. The is Touching() method determines if the two bodies are in contact, and if so, the World Manifold object is used to obtain information about the collision. This method was utilized to determine if the legs were grounded. Contact listeners were also employed to detect and respond to collisions between bodies in the simulation, adding custom behaviours to the game or simulation when certain objects collide. The traps and interactable in the game utilized contact listeners to provide unique behaviour."
            },
            {
                type: "collapsible",
                value: "CODE SNIPPET",
                content: [
                    { type: "text", value: "Code for contact collision to check if grounded." },
                    { type: "image", value: "Images/groundedCode.png", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Leggy's Logic Full Game video"
            },
            {
            type: "youtube",
            value: "K1KjsxNcw8Q?si=uXvpGA8by2WxQode" // Replace "VideoID" with the actual ID of the YouTube video
            },
            {
                type: "heading",
                value: "Leggy's Logic with skeleton video"
            },
            {
            type: "youtube",
            value: "mnie5i5dTR8?si=DvvgkjClqGS6nX18" // Replace "VideoID" with the actual ID of the YouTube video
            },

            /*{
                
                type: "gif",
                value: "Images/dayNightGIF.gif",
                alt: "Animation Highlighting Challenges",
                orientation: "landscape"
                orientation: "landscape"
            },*/
            {
                type: "text",
                value: "The game's download link is below."
            },
            {
                type: "link",
                value: "Download",
                url: "https://aquwin11.itch.io/leggys-logic",
                linkType: "text" // Could be "text","icon" or "image" with appropriate handling
            }
        ]
    },
    project3: {
        title: "The Calling",
        img: "Images/calling.jpg",
        tech: ["C#", "Unity"],
        content: [
            // Example of a heading
            {
                type: "link",
                value: "bi-github",
                url: "https://github.com/Aquwin11/FPS",
                linkType: "icon" // Could be "text","icon" or "image" with appropriate handling
            },
            {
                type: "text",
                value: "This game was developed as part of my course and its story is still in developement."
            },
            {
                type: "heading",
                value: "Combat"
            },
            {
                type: "text",
                value: "The player uses the gun throughout the game. The gun is not only used for combat but also to solve puzzles. The handgun doubles as a torch also, which can be used in hard-to-see places. The shooting is done by ray casting, if the ray hit an enemy the enemy takes damage. The gun also has a custom animation. The character control was built from the ground up, the gun sways left and right the player moves horizontally, and it lags behind when the player moves the mouse way too fast. All these effects were obtained by Lerping and Swaying the gun's pivot to the desired position. The gun has a run, idle, and walk animation which was done using an animator. The gun automatically reloads once the player magazine empties."
            },
            {
                type: "heading",
                value: "Zombies"
            },
            {
                type: "text",
                value: "In the previous build, the enemy would go into its alert state as soon as the player enters inside its range. This seemed unnatural, so I implemented line of sight. Where the enemy can see the player only if the player enters its vision cone. The challenge was not to put this code on the update function. Instead, it runs in a coroutine that calls itself continuously. Another change made was creating a parent class for the enemy (Abstract class) which can define common variables used between the different enemies like health vision radius."
            },
            {
                type: "collapsible",
                value: "Enemy State Machine",
                content: [
                    { type: "image", value: "Images/AI_state.png", alt: "Example", orientation: "landscape"},
                    { type: "text", value: "The enemy has 7 states that it transitions between. In patrolling phase, the enemy walks, to a random waypoint specified by the developer. Once the enemy reaches one of these random waypoints it goes into an idle state, where it waits for a certain amount of time and then continues to patrol. The next stage is the chase state, which is active when the player enters the enemy's vision. The enemy Looks At the player and begins to run toward the player. The next phase is the attack phase. In this phase, the enemy can attack and deal damage to the player if they are close or in the attack range. The stun phase is where the enemy can be stunned by the player. This is not true every time, the enemy can be stunned after a certain period of time since its last stun. Once the enemy takes enough damage it dies, as a unique feature, the enemy can reanimate itself with full health. FigMovement." },
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Weeping Angel"
            },
            {
                
                type: "gif",
                value: "Images/enemy3.gif",
                alt: "Animation Highlighting Challenges",
                orientation: "landscape"
            },
            {
                type: "text",
                value: "The second type of enemy was built more for a puzzle component than a combat scenario. The enemies were inspired by the weeping angels from Doctor Who. The statue moves when the player is not looking at it. This is done similarly to the first enemy, but the difference is if the player's camera is not rendering the enemy and the player is in the enemies’ range then it will start to follow the player. Once the enemy goes close to the player it deals an instant kill on the player."
            },
            {
                type: "collapsible",
                value: "CODE SNIPPET for FOV",
                content: [
                    { type: "image", value: "Images/enemy3FOV.png", alt: "Example", orientation: "landscape"},
                    { type: "text", value: "The enemy has 8 states that it transitions between. In patrolling phase, the enemy walks, to a random waypoint specified by the developer. Once the enemy reaches one of these random waypoints it goes into an idle state, where it waits for a certain amount of time and then continues to patrol. The next stage is the chase state, which is active when the player enters the enemy's vision. The enemy Looks At the player and begins to run toward the player. The next phase is the attack phase. In this phase, the enemy can attack and deal damage to the player if they are close or in the attack range. The stun phase is where the enemy can be stunned by the player. This is not true every time, the enemy can be stunned after a certain period of time since its last stun. Once the enemy takes enough damage it dies, as a unique feature, the enemy can reanimate itself with full health. FigMovement." },
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Puzzels"
            },
            {
                type: "text",
                value: "The main objective of the games is to get to the root of what is causing this supernatural phenomenon. The player can solve this problem by completing a series of puzzles and exploring the mansion. The player can solve these puzzles by interacting with the world. There are a series of checks that the player script does to see which puzzle or object the player is intending to interact with. The story of the game is revealed in the game world through different interactable objects like letters and notes."
            },
            {
                type: "collapsible",
                value: "Puzzel One",
                content: [
                    { type: "text", value: "For the first puzzle, the player must read a note in the current room. To read the note the player must get close to the letters and click “E”. On doing so a new UI opens with allows the player to read the description of the letter. The riddle hints at the player to make the room dark. If the player shoots the bulb the light goes off including an illusion of a cupboard." },
                    { type: "gif", value: "Images/puzzleone.gif", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "collapsible",
                value: "Puzzel Two",
                content: [
                    { type: "text", value: "The second puzzle can be solved by again interacting with a letter that provides a hint and the player to rearrange a bunch of photos. This is accomplished by storing the mesh and the selected game object in a buffer and replacing them once the player selects another image the player wanted to swap the original image with. Same as the previous one the player is given hints on solving this through a letter. But if the player explored the previous floor carefully, he could see the second puzzle original puzzle." },
                    { type: "gif", value: "Images/puzzle2.gif", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "collapsible",
                value: "Puzzel Three",
                content: [
                    { type: "text", value: "In this puzzle, the player has to set the time of different clocks based on the riddle given to the player. The problem is that the riddle is incomplete. The messing information is hidden in the statue in front of each clock. The player is given the ability to examine these game objects and even rotate to look for clues. Similar to the letters and GUI pops up which gives the player a description of the current object that is being examined. For each of these puzzles, the player is rewarded with a key from a closed box. These keys allow the player to progress with the story. There is a fourth partial puzzle, it is not a puzzle in a traditional term. This puzzle will have to deal with a new type of new that was not present in the demo build." },
                    { type: "gif", value: "Images/puzzle3.gif", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Game Video"
            },
            {
            type: "youtube",
            value: "LYy2emhPXxo?si=eM_0kxA3OEQabehl" // Replace "VideoID" with the actual ID of the YouTube video
            },

            /*{
                
                type: "gif",
                value: "Images/dayNightGIF.gif",
                alt: "Animation Highlighting Challenges",
                orientation: "landscape"
                orientation: "landscape"
            },*/
            {
                type: "text",
                value: "The game's download link is below."
            },
            {
                type: "link",
                value: "Download",
                url: "https://aquwin11.itch.io/the-calling",
                linkType: "text" // Could be "text","icon" or "image" with appropriate handling
            }
        ]
    },
    project4: {
        title: "Rootopia",
        img: "Images/rootopia.png",
        tech: ["C#", "Unity","Game Jam"],
        content: [
            {
                type: "text",
                value: "Rootopia is a tower defence game, developed as part of the Global Game Jam 2023(theme-'Roots'), where I and 5 other participated in. My contribution was the development of various  the traps in the game."
            },
            {
                type: "heading",
                value: "Traps"
            },
            {
                type: "text",
                value: "In tower defence games, player abilities, and traps are critical components that contribute to the game's overall experience. Rootopia is a game that features four distinct traps, each with its own unique benefits. Each trap offers a different set of advantages, allowing players to customize their defence strategies and adapt to various gameplay situations."
            },
            {
                type: "heading",
                value: "Walls"
            },
            {
                
                type: "gif",
                value: "Images/RootopiaWall.gif",
                alt: "Animation Highlighting Challenges",
                orientation: "landscape"
            },
            {
                type: "text",
                value: "The wall is the most basic trap among the four available in Rootopia. It serves as a defensive barrier for the player and can also act as an obstacle for enemies, preventing them from reaching certain locations When the wall is instantiated in the game scene, it is initially offset by a certain value in the y-position. With the use of an animator component, the wall is animated in a way that it appears to rise from the ground."
            },
            {
                type: "heading",
                value: "Spikes"
            },
            {
                
                type: "gif",
                value: "Images/RootopiaSpikes.gif",
                alt: "Animation Highlighting Challenges",
                orientation: "landscape"
            },
            {
                type: "text",
                value: "The Spike Trap is a powerful trap that deals significant damage to enemies who step on it.The spike prefab consists of a collider and a rigid body, when the colliders are triggered the spikes raise up from the spike prefab and deal damage to which every enemy is standing on it.."
            },
            {
                type: "heading",
                value: "Acid Flower"
            },
            {
                
                type: "gif",
                value: "Images/RootopiaFlowers.gif",
                alt: "Animation Highlighting Challenges",
                orientation: "landscape"
            },
            {
                type: "text",
                value: "The Flower Trap in Rootopia is a unique trap that has two different effects on enemies. The Flower Trap slows down enemies and deals a small amount of damage over time. The Flower Trap's design is intended to provide players with a more strategic option for dealing with enemy waves. The trap is triggered when the enemy stays within the trap's collision. During this state, the traps access the enemy animator and Nav-Agent and set a low movement and animation speed. Using on OnCollisonEnd function it resets its movement and animation speed to the original value."
            },
            {
                type: "heading",
                value: "Turret Branch"
            },
            {
                
                type: "gif",
                value: "Images/RootopiaBranches.gif",
                alt: "Animation Highlighting Challenges",
                orientation: "potrait"
            },
            {
                type: "text",
                value: "The Turret Branch is a powerful range trap that deals damage to enemies within its range ,the Turret Branch has a light sight requirement. To implement the Turret Branch in Rootopia, a two-ray cast system is used to determine if the trap has a line of sight to the enemy. The two rays are cast from the Turret Branch's position towards the enemy, and if there is no obstacle between them, the trap will fire and deal damage to the enemy."
            },
            {
                type: "heading",
                value: "Game Video"
            },
            {
            type: "youtube",
            value: "qowFf8QGtrw?si=56DvU_TQ6rEFa3qU" // Replace "VideoID" with the actual ID of the YouTube video
            },
            {
                type: "text",
                value: "The game's download link is below."
            },
            {
                type: "link",
                value: "Download",
                url: "https://aquwin11.itch.io/rootopia",
                linkType: "text" // Could be "text","icon" or "image" with appropriate handling
            }
        ]
    },

    project5: {
        title: "Alien Shooter",
        img: "Images/newAlien_Shooter.jpg",
        tech: ["C#", "Unity2D"],
        content: [
        {
                type: "link",
                value: "bi-github",
                url: "https://github.com/Aquwin11/Alien-Shooter",
                linkType: "icon" // Could be "text","icon" or "image" with appropriate handling
            },
            {
                type: "heading",
                value: "Design"
            },
            {
                type: "text",
                value: "This game challenges players to engage in non-stop action, navigating through the cosmos while battling a relentless alien force. The key design feature centers around energy management; players must keep their energy bar replenished to survive. The game encourages an aggressive playstyle, rewarding players for staying on the offensive. Each enemy vanquished not only boosts the player's score but also replenishes a portion of their energy bar, creating a dynamic balance between attack and defense."
            },
            {
                type: "collapsible",
                value: "Movement",
                content: [
                    { type: "text", value: "Use the left side of the screen to maneuver your ship across the 2D plane. This will help you dodge obstacles and enemy attacks." },
                    { type: "image", value: "Images/movementHTP.png", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "collapsible",
                value: "Combat and Defense",
                content: [
                    { type: "text", value: "The right side of the screen features two primary actions: Shoot and Activate Shield. Every shot fired consumes energy. As you fire continuously, the energy depletes and takes time to recharge. When the ship's energy is fully depleted, you'll need to wait for it to recharge fully before firing again." },
                    { type: "image", value: "Images/comabtHTP.png", alt: "Example", orientation: "potrait"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "collapsible",
                value: "Energy Management",
                content: [
                    { type: "text", value: "Restore energy faster by activating your shield. Blocking attacks or colliding with enemy ships while the shield is active regains energy. However, be cautious! Using the shield consumes energy at a rapid rate and prevents your ship from shooting." },
                    { type: "image", value: "Images/energyHTP.png", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "collapsible",
                value: "Enemies",
                content: [
                    { type: "heading", value: "Speedster" },
                    { type: "text", value: " Speedster is a basic enemy type that charges towards your ship at high velocities. Quick reflexes and sharp maneuvers are essential to evade these relentless foes." },
                    { type: "image", value: "Images/Speedster.png", alt: "Example", orientation: "landscape"},
                    { type: "heading", value: "Artillery Sentinel" },
                    { type: "text", value: " The Artillery Sentinel is armed with a radar system. Upon detecting your ship in its vicinity, it immediately releases a deadly projectile." },
                    { type: "image", value: "Images/Sentinel.png", alt: "Example", orientation: "landscape"},
                    { type: "heading", value: "Shielded Cruiser" },
                    { type: "text", value: " Among the most challenging enemies, the Shielded Cruiser boasts a protective shield, making direct ramming tactics futile. " },
                    { type: "image", value: "Images/Shielded.png", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Game Video"
            },
            {
            type: "youtube",
            value: "-GQvNdNhgwA?si=VZ3AZXr5YdxJ32yv" // Replace "VideoID" with the actual ID of the YouTube video
            },
            {
                type: "text",
                value: "The game's download link is below."
            },
            {
                type: "link",
                value: "Download",
                url: "https://aquwin11.itch.io/alien",
                linkType: "text" // Could be "text","icon" or "image" with appropriate handling
            }
        ]
    },
    project6: {
        title: "The Elemental",
        img: "Images/elemental.png",
        tech: ["C#", "Unity"],
        content: [
            {
                type: "link",
                value: "bi-github",
                url: "https://github.com/Aquwin11/Elemental",
                linkType: "icon" // Could be "text","icon" or "image" with appropriate handling
            },
            {
                type: "text",
                value: "Elemental is a rogue-lite game created utilizing Procedural Content Generation (PCG) and Dynamic Animation. The game was developed in Unity for my final  project in university. The game is still in development."
            },
            {
                type: "heading",
                value: "Procedural Animation"
            },
            {
                type: "text",
                value: "Given the character encounters various non-flat surfaces due to procedural terrain generation, incorporating procedural animation was crucial to enhance the overall game experience and realism. Accurate foot placement was achieved through inverse kinematics (IK), ensuring realistic positioning. The use of 'OnAnimatorIK,' a built-in Unity function, allows for real-time adjustment of foot animations. This function casts a downward ray from above the foot's IK position and uses 'Physics.Raycast' to detect ground contact. It then adjusts the IK position based on the ray's ground contact. IK rotation handling is also implemented, mirroring foot lifting with foot rotation and using the surface normal at the ray's impact point for realistic foot orientation."
            },
            { type: "gif", value: "Images/newwithIKGIF.gif", alt: "Example", orientation: "landscape"},
            {
                type: "collapsible",
                value: "Foot IK CODESNIPPET",
                content: [
                    { type: "image", value: "Images/newTest.png", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "collapsible",
                value: "Rigging Package",
                content: [
                    { type: "text", value: "Using the Unity Rigging Package, I enhanced creature animations, particularly with the 'Two Bone IK Constraint'. This constraint functions like puppet strings, ensuring lifelike limb movements in areas such as the 'arm', 'forearm', and 'hand'. The 'Rig Builder Component', added to the creature's root, forms the foundation for the 'Rig Setup', using targets as guides for animation. The 'Perform Step' method fine-tunes leg joint animations. It continuously evaluates velocity and orchestrates leg motions. These persistent adjustments ensure that the creature's body orientation aligns with realistic movements." },
                    { type: "gif", value: "Images/enemyMovement.gif", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Player Movement"
            },
            {
                type: "text",
                value: "Given the game's dynamic build, ensuring the character's mobility was essential. Therefore, the player is equipped with abilities like gliding, dashing, sprinting, and climbing to facilitate exploration. Each serves a unique purpose, aiding exploration and problem-solving. Dashing is a quick burst of speed, while sprinting is sustained. Climbing adds verticality to exploration, and gliding offers an aerial perspective, enhancing the game's sense of freedom and discovery."
            },
            { type: "gif", value: "Images/movement.gif", alt: "Example", orientation: "landscape"},
            {
                type: "collapsible",
                value: "Player Combat",
                content: [
                    { type: "text", value: "Players have the flexibility to tailor their combat approach. They can engage enemies directly, relying on quick reflexes and melee abilities, or opt for a strategic distance combat, utilizing precision aiming. This variety ensures a combat style suitable for every player's preference." },
                    { type: "gif", value: "Images/combatgif.gif", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Enemy AI"
            },
            {
                type: "text",
                value: "Similar to the player, the game's AI has both melee and ranged engagement options. The AI uses a state machine, toggling between idle and chase modes based on player proximity. When players near, enemies switch to chase mode, intensifying combat. Enemies deploy both long-range and close combat tactics. They initiate ranged attacks when players enter their shooting radius, but this is regulated by a fire rate to prevent constant firing. Importantly, enemies visually align with players before a ranged attack, signaling players to strategize their defense."
            },
            { type: "gif", value: "Images/enemyAI.gif", alt: "Example", orientation: "landscape"},
            {
                type: "heading",
                value: "Procedural Terrain Generation"
            },
            {
                type: "text",
                value: "In procedural terrain generation, noise functions like Perlin noise are crucial in producing natural-looking randomness that represents terrain height. Perlin noise, with its organic gradients, is especially favored for crafting hills and valleys. To add terrain complexity, noise is layered in 'octaves', with each layer building upon the previous. Adjusting each octave's frequency and amplitude allows for terrain variations, from gentle hills to rugged mountains. Frequency determines terrain feature frequency, while amplitude controls their prominence. Overall, noise functions offer the essential randomness for realistic, organically varied terrains in procedural generation."
            },
            {
                type: "collapsible",
                value: "Falloff Map",
                content: [
                    { type: "text", value: "A falloff map crafts island-like landscapes by making the terrain's edges decline, resembling an island encircled by water. It can be generated using designated start and end points or a mathematical formula. This approach is popular in procedural terrain generation for designing standalone islands." },
                    { type: "gif", value: "Images/falloffGig.gif", alt: "Example", orientation: "potrait"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "collapsible",
                value: "Terrain Shader",
                content: [
                    { type: "text", value: "The terrain shader dynamically applies appropriate textures to the terrain based on its height. By sampling the height values within the terrain, the shader selectively blended between different textures, such as grass, rocks, or sand, to depict realistic landscapes." },
                    { type: "gif", value: "Images/TerrainShdader.gif", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "collapsible",
                value: "Placement Generator",
                content: [
                    { type: "text", value: "The Placement Generator populates a game scene with diverse objects. It picks random locations based on set criteria, and when a location is deemed suitable, it places an object there, adjusting its rotation and size. This ensures that every game environment it creates is both varied and logically structured." },
                    { type: "gif", value: "Images/PlacementGeneratorGif.gif", alt: "Example", orientation: "landscape"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Day night cycle Shader"
            },
            {
                type: "text",
                value: "To add to the dynamism and liveliness of the world, a day-night cycle was implemented. This cycle offers an aesthetic change and introduces the following features"
            },
            {
                type: "text",
                value: "Real-time Transition: The progression from day to night is seamless, with the sun and moon tracking across the sky, casting real-time shadows and creating diverse lighting effects."
            },
            {
                type: "text",
                value: "Dynamic Lighting: Depending on the time of day, players can experience varying lighting atmospheres. Dawn might be greeted with a soft, warm glow, midday with a bright, clear light, and nighttime with the serene illumination of the moon and stars."
            },
            { type: "gif", value: "Images/dayNightGIF.gif", alt: "Example", orientation: "landscape"},
            {
                type: "heading",
                value: "User Interface"
            },
            {
                type: "text",
                value: "I designed the game's user interface (UI) with clarity and user-friendliness in mind. Utilizing the DoTween library, I added dynamic UI animations for a more engaging visual experience. Moreover, I developed custom scripts to ensure consistent behavior across the UI. This setup enabled users to easily adjust audio and game settings to their preference."
            },
            { type: "gif", value: "Images/UITransitionGIF.gif", alt: "Example", orientation: "landscape"},
            {
                type: "heading",
                value: "Game Video"
            },
            {
            type: "youtube",
            value: "SiiakDzjFTo?si=X6vsGFApARp5TK1G" // Replace "VideoID" with the actual ID of the YouTube video
            },
            {
                type: "text",
                value: "The game's download link is below."
            },
            {
                type: "link",
                value: "Download",
                url: "https://aquwin11.itch.io/elemental",
                linkType: "text" // Could be "text","icon" or "image" with appropriate handling
            }
        ]
    },
    project7: {
        title: "Zombie Arena",
        img: "Images/background.png",
        tech: ["C++"],
        content: [
            // Example of a heading
            {
                type: "link",
                value: "bi-github",
                url: "https://github.com/Aquwin11/zombie_Arena",
                linkType: "icon" // Could be "text","icon" or "image" with appropriate handling
            },
            {
                type: "heading",
                value: "Combat"
            },
            {
                type: "text",
                value: "In Zombie Arena, players have access to an arsenal of four distinct types of guns to combat the undead hordes: pistols, assault rifles, snipers, and shotguns, each with unique attributes suited to various playstyles and strategies. Ammunition for these firearms is dispersed randomly throughout the game world, introducing an element of unpredictability and scarcity that compels players to continually adapt their weapon use. Additionally, med kits are dropped randomly in the game world whenever zombies are defeated, providing essential health recovery. The scarcity of ammunition forces players to rotate among their available weapons, ensuring a dynamic combat experience that requires thoughtful management of resources."
            },
            {
                
                type: "gif",
                value: "Images/ZombieArenaShoot.gif",
                alt: "Animation Highlighting Challenges",
                orientation: "landscape"
            },
            {
                type: "collapsible",
                value: "Shooting CODE SNIPPET",
                content: [
                    { type: "heading", value: "Shooting" },
                    { type: "image", value: "Images/check.png", alt: "Example"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Zombies"
            },
            {
                type: "text",
                value: "In the game, players encounter three distinct types of zombies, each with their unique quirks, adding depth and strategy to the gameplay. The Chaser zombie stands out as the fastest, relentlessly pursuing the player across the battlefield. In contrast, the Bloater acts as a formidable tank, absorbing substantial damage and dealing the most harm to its opponents. The third type, the Crawler, moves at a slower pace and deals the least amount of damage. However, it compensates for its sluggishness with a unique ability to fire projectiles at the player. With each wave, the number of zombies increases, presenting escalating challenges and requiring players to adapt their strategies to survive the growing undead onslaught."
            },
            {
                
                type: "gif",
                value: "Images/ZombieArenaEnemy.gif",
                alt: "Animation Highlighting Challenges",
                orientation: "landscape"
            },
            {
                type: "collapsible",
                value: "Enemy CODE SNIPPET",
                content: [
                    { type: "heading", value: "Enemy" },
                    { type: "image", value: "Images/za_zombie.png", alt: "Example"},
                    // Include code snippets, GIFs, videos, etc., as needed
                ]
            },
            {
                type: "heading",
                value: "Leveling-Up"
            },
            {
                type: "text",
                value: "After each wave in Zombie Arena, players are presented with the chance to level up their character, a key feature that deeply influences the game's dynamics and allows for personalized playstyles. This leveling-up process empowers players to strategically enhance their character's abilities or weapon effectiveness, enabling them to decide whether to specialize in a specific combat style or adopt a more balanced approach to survival. The variety of upgrades available ensures that players can adapt and refine their tactics to face the increasing zombie threats more effectively, shaping their journey through the game according to their preferences and playstyle."
            },
            {
                
                type: "image",
                value: "Images/levelingup.png",
                alt: "Animation Highlighting Challenges",
                orientation: "landscape"
            },
            {
                type: "heading",
                value: "Game Video"
            },
            {
            type: "youtube",
            value: "_fG9-TL_ktk?si=q-MNGKYhdQF9pD_j" // Replace "VideoID" with the actual ID of the YouTube video
            },
            {
                type: "text",
                value: "The game's download link is below."
            },
            {
                type: "link",
                value: "Download",
                url: "https://aquwin11.itch.io/zombie-arena",
                linkType: "text" // Could be "text","icon" or "image" with appropriate handling
            }
        ]
    },
    project8: {
        title: "TWL",
        img: "Images/TWL.png",
        tech: ["C++"],
        content: [
            // Example of a heading
            {
                type: "link",
                value: "bi-github",
                url: "https://github.com/Aquwin11/TWL",
                linkType: "icon" // Could be "text","icon" or "image" with appropriate handling
            },
            {
                type: "text",
                value: "The development of this game began with a course on Udemy, and I am still working on the game engine and playable character. The main objective of the game is for players to collaborate in solving time-based puzzles."
            },
        ]
    },
    // More projects...
};


// Function to parse URL parameters
function getProjectIdFromURL() {
    const queryParams = new URLSearchParams(window.location.search);
    return queryParams.get('id');
}
// Call the function to load details when the page loads
document.addEventListener('DOMContentLoaded', loadProjectDetails);

function loadProjectDetails() {
    const projectId = getProjectIdFromURL();
    const project = projects[projectId];

    if (project) {
        const container = document.getElementById('project-detail-container');
        const techHTML = project.tech ? project.tech.map(tech => `<span class="project-tech-item">${tech}</span>`).join('') : '';
        let contentHTML = '';

        project.content.forEach(item => {
            switch(item.type) {
                case "text":
                    contentHTML += `<p>${item.value}</p>`;
                    break;
                case "image":
                case "gif":
                    const orientationClass = item.orientation ? `img-${item.orientation}` : '';
                    contentHTML += `<img src="${item.value}" alt="${item.alt}" class="${item.type} ${orientationClass}">`;
                    break;
                case "heading":
                    contentHTML += `<h4>${item.value}</h4>`;
                    break;
                case "link":
                    if (item.linkType === "text") {
                        contentHTML += `<a href="${item.url}" class="project-link">${item.value}</a>`;
                    } else if (item.linkType === "icon") {
                        contentHTML += `<a href="${item.url}" class="project-link-icon"><i class="bi ${item.value}"></i></a>`;
                    } else if (item.linkType === "image") {
                        contentHTML += `<a href="${item.url}" class="project-link-image"><img src="${item.value}" alt="Link"></a>`;
                    }
                    break;
                case "youtube":
                    contentHTML += `
                        <div class="video-container">
                            <iframe width="560" height="315" src="https://www.youtube.com/embed/${item.value}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                        </div>
                    `;
                    break;

                case "collapsible":
                    let collapsibleContentHTML = item.content.map(subItem => {
                        switch(subItem.type) {
                            case "heading": return `<h4>${subItem.value}</h4>`;
                            case "text": return `<p>${subItem.value}</p>`;
                            case "image": return `<img src="${subItem.value}" alt="${subItem.alt}" class="img-${subItem.orientation || 'default'}">`;
                            case "gif": return `<img src="${subItem.value}" alt="${subItem.alt}" class="${subItem.type} ${subItem.orientationClass|| 'default'}">`;
                            // Add cases for gif, video, etc.
                            default: return '';
                        }
                    }).join('');

                    contentHTML += `
                        <div class="collapsible">
                            <div class="collapsible-header">${item.value}</div>
                            <div class="collapsible-content">${collapsibleContentHTML}</div>
                        </div>
                    `;
                    break;
            }
        });

        // Combine the image container with the rest of the content
        const projectImageHTML = `
            <div class="project-img-container">
                <img src="${project.img}" alt="${project.title}" class="project-main-image">
                <div class="project-title-overlay">${project.title}</div>
            </div>
        `;

        container.innerHTML = projectImageHTML + `<div class="project-tech">${techHTML}</div>` + contentHTML;

        // Add event listeners to collapsible headers after content is loaded
        document.querySelectorAll('.collapsible-header').forEach(header => {
            header.addEventListener('click', function() {
                this.classList.toggle('active');
                var content = this.nextElementSibling;
                if (content.style.display === "block") {
                    content.style.display = "none";
                } else {
                    content.style.display = "block";
                }
            });
        });
    } else {
        container.innerText = 'Project details not found.';
    }
}
document.querySelectorAll('.collapsible-header').forEach(header => {
    header.addEventListener('click', function() {
        const content = this.nextElementSibling;
        if (content.style.maxHeight) {
            content.style.maxHeight = null; // Collapse
            this.classList.remove('active');
        } else {
            // Expand
            content.style.maxHeight = content.scrollHeight + "px";
            this.classList.add('active');
        }
    });
});


    </script>
  </body>
</html>  